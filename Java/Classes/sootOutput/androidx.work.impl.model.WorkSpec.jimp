public final class androidx.work.impl.model.WorkSpec extends java.lang.Object
{
    public static final long SCHEDULE_NOT_REQUESTED_YET;
    private static final java.lang.String TAG;
    public static final androidx.arch.core.util.Function WORK_INFO_MAPPER;
    public long backoffDelayDuration;
    public androidx.work.BackoffPolicy backoffPolicy;
    public androidx.work.Constraints constraints;
    public boolean expedited;
    public long flexDuration;
    public java.lang.String id;
    public long initialDelay;
    public androidx.work.Data input;
    public java.lang.String inputMergerClassName;
    public long intervalDuration;
    public long minimumRetentionDuration;
    public androidx.work.OutOfQuotaPolicy outOfQuotaPolicy;
    public androidx.work.Data output;
    public long periodStartTime;
    public int runAttemptCount;
    public long scheduleRequestedAt;
    public androidx.work.WorkInfo$State state;
    public java.lang.String workerClassName;

    static void <clinit>()
    {
        java.lang.String $r0;
        androidx.work.impl.model.WorkSpec$1 $r1;

        $r0 = androidx.work.Logger.tagWithPrefix("WorkSpec");

        androidx.work.impl.model.WorkSpec.TAG = $r0;

        $r1 = new androidx.work.impl.model.WorkSpec$1;

        specialinvoke $r1.<init>();

        androidx.work.impl.model.WorkSpec.WORK_INFO_MAPPER = $r1;

        return;
    }

    public void <init>(androidx.work.impl.model.WorkSpec)
    {
        androidx.work.BackoffPolicy $r5;
        androidx.work.Constraints $r4, $r9;
        long $l0;
        androidx.work.impl.model.WorkSpec r0, $r1;
        androidx.work.WorkInfo$State $r2;
        int $i1;
        androidx.work.OutOfQuotaPolicy $r6;
        java.lang.String $r7;
        androidx.work.Data $r3, $r8;
        boolean $z0;

        r0 := @this;

        $r1 := @parameter0;

        specialinvoke r0.<init>();

        $r2 = androidx.work.WorkInfo$State.ENQUEUED;

        r0.state = $r2;

        $r3 = androidx.work.Data.EMPTY;

        r0.input = $r3;

        $r3 = androidx.work.Data.EMPTY;

        r0.output = $r3;

        $r4 = androidx.work.Constraints.NONE;

        r0.constraints = $r4;

        $r5 = androidx.work.BackoffPolicy.EXPONENTIAL;

        r0.backoffPolicy = $r5;

        r0.backoffDelayDuration = 30000L;

        r0.scheduleRequestedAt = -1L;

        $r6 = androidx.work.OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST;

        r0.outOfQuotaPolicy = $r6;

        $r7 = $r1.id;

        r0.id = $r7;

        $r7 = $r1.workerClassName;

        r0.workerClassName = $r7;

        $r2 = $r1.state;

        r0.state = $r2;

        $r7 = $r1.inputMergerClassName;

        r0.inputMergerClassName = $r7;

        $r3 = new androidx.work.Data;

        $r8 = $r1.input;

        specialinvoke $r3.<init>($r8);

        r0.input = $r3;

        $r3 = new androidx.work.Data;

        $r8 = $r1.output;

        specialinvoke $r3.<init>($r8);

        r0.output = $r3;

        $l0 = $r1.initialDelay;

        r0.initialDelay = $l0;

        $l0 = $r1.intervalDuration;

        r0.intervalDuration = $l0;

        $l0 = $r1.flexDuration;

        r0.flexDuration = $l0;

        $r4 = new androidx.work.Constraints;

        $r9 = $r1.constraints;

        specialinvoke $r4.<init>($r9);

        r0.constraints = $r4;

        $i1 = $r1.runAttemptCount;

        r0.runAttemptCount = $i1;

        $r5 = $r1.backoffPolicy;

        r0.backoffPolicy = $r5;

        $l0 = $r1.backoffDelayDuration;

        r0.backoffDelayDuration = $l0;

        $l0 = $r1.periodStartTime;

        r0.periodStartTime = $l0;

        $l0 = $r1.minimumRetentionDuration;

        r0.minimumRetentionDuration = $l0;

        $l0 = $r1.scheduleRequestedAt;

        r0.scheduleRequestedAt = $l0;

        $z0 = $r1.expedited;

        r0.expedited = $z0;

        $r6 = $r1.outOfQuotaPolicy;

        r0.outOfQuotaPolicy = $r6;

        return;
    }

    public void <init>(java.lang.String, java.lang.String)
    {
        androidx.work.BackoffPolicy $r6;
        androidx.work.Constraints $r5;
        androidx.work.impl.model.WorkSpec r0;
        androidx.work.WorkInfo$State $r3;
        java.lang.String $r1, $r2;
        androidx.work.OutOfQuotaPolicy $r7;
        androidx.work.Data $r4;

        r0 := @this;

        $r1 := @parameter0;

        $r2 := @parameter1;

        specialinvoke r0.<init>();

        $r3 = androidx.work.WorkInfo$State.ENQUEUED;

        r0.state = $r3;

        $r4 = androidx.work.Data.EMPTY;

        r0.input = $r4;

        $r4 = androidx.work.Data.EMPTY;

        r0.output = $r4;

        $r5 = androidx.work.Constraints.NONE;

        r0.constraints = $r5;

        $r6 = androidx.work.BackoffPolicy.EXPONENTIAL;

        r0.backoffPolicy = $r6;

        r0.backoffDelayDuration = 30000L;

        r0.scheduleRequestedAt = -1L;

        $r7 = androidx.work.OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST;

        r0.outOfQuotaPolicy = $r7;

        r0.id = $r1;

        r0.workerClassName = $r2;

        return;
    }

    public long calculateNextRunTime()
    {
        androidx.work.BackoffPolicy r1, $r2;
        long $l0, $l1, l2, l5, $l6;
        androidx.work.impl.model.WorkSpec r0;
        byte b4;
        int $i3;
        float f0;
        boolean $z0, z1;

        r0 := @this;

        $z0 = virtualinvoke r0.isBackedOff();

        z1 = 0;

        if $z0 == 0 goto label04;

        r1 = r0.backoffPolicy;

        $r2 = androidx.work.BackoffPolicy.LINEAR;

        if r1 != $r2 goto label01;

        z1 = 1;

     label01:
        if z1 == 0 goto label02;

        l2 = r0.backoffDelayDuration;

        $i3 = r0.runAttemptCount;

        $l0 = (long) $i3;

        $l0 = l2 * $l0;

        goto label03;

     label02:
        l2 = r0.backoffDelayDuration;

        f0 = (float) l2;

        $i3 = r0.runAttemptCount;

        $i3 = $i3 - 1;

        f0 = java.lang.Math.scalb(f0, $i3);

        $l0 = (long) f0;

     label03:
        l2 = r0.periodStartTime;

        $l0 = java.lang.Math.min(18000000L, $l0);

        l2 = l2 + $l0;

        return l2;

     label04:
        $z0 = virtualinvoke r0.isPeriodic();

        l2 = 0L;

        if $z0 == 0 goto label12;

        $l1 = java.lang.System.currentTimeMillis();

        $l0 = r0.periodStartTime;

        b4 = $l0 cmp 0L;

        if b4 != 0 goto label05;

        l5 = r0.initialDelay;

        l5 = l5 + $l1;

        goto label06;

     label05:
        l5 = $l0;

     label06:
        $l1 = r0.flexDuration;

        $l6 = r0.intervalDuration;

        b4 = $l1 cmp $l6;

        if b4 == 0 goto label07;

        z1 = 1;

     label07:
        if z1 == 0 goto label09;

        b4 = $l0 cmp 0L;

        if b4 != 0 goto label08;

        l2 = $l1 * -1L;

     label08:
        $l0 = $l6 + l5;

        l2 = $l0 + l2;

        return l2;

     label09:
        b4 = $l0 cmp 0L;

        if b4 != 0 goto label10;

        goto label11;

     label10:
        l2 = $l6;

     label11:
        l2 = l5 + l2;

        return l2;

     label12:
        l2 = r0.periodStartTime;

        b4 = l2 cmp 0L;

        if b4 != 0 goto label13;

        l2 = java.lang.System.currentTimeMillis();

     label13:
        $l0 = r0.initialDelay;

        l2 = $l0 + l2;

        return l2;
    }

    public boolean equals(java.lang.Object)
    {
        androidx.work.BackoffPolicy $r13, $r14;
        androidx.work.Constraints $r11, $r12;
        long $l0, $l1;
        androidx.work.impl.model.WorkSpec r0, r4;
        byte $b2;
        int $i3, $i4;
        java.lang.String $r5, $r6;
        androidx.work.OutOfQuotaPolicy $r15, $r16;
        androidx.work.Data $r9, $r10;
        boolean $z0, $z1;
        androidx.work.WorkInfo$State $r7, $r8;
        java.lang.Object $r1;
        java.lang.Class $r2, $r3;

        r0 := @this;

        $r1 := @parameter0;

        if r0 != $r1 goto label01;

        return 1;

     label01:
        if $r1 == null goto label21;

        $r2 = virtualinvoke r0.getClass();

        $r3 = virtualinvoke $r1.getClass();

        if $r2 == $r3 goto label02;

        return 0;

     label02:
        r4 = (androidx.work.impl.model.WorkSpec) $r1;

        $l0 = r0.initialDelay;

        $l1 = r4.initialDelay;

        $b2 = $l0 cmp $l1;

        if $b2 == 0 goto label03;

        return 0;

     label03:
        $l0 = r0.intervalDuration;

        $l1 = r4.intervalDuration;

        $b2 = $l0 cmp $l1;

        if $b2 == 0 goto label04;

        return 0;

     label04:
        $l0 = r0.flexDuration;

        $l1 = r4.flexDuration;

        $b2 = $l0 cmp $l1;

        if $b2 == 0 goto label05;

        return 0;

     label05:
        $i3 = r0.runAttemptCount;

        $i4 = r4.runAttemptCount;

        if $i3 == $i4 goto label06;

        return 0;

     label06:
        $l0 = r0.backoffDelayDuration;

        $l1 = r4.backoffDelayDuration;

        $b2 = $l0 cmp $l1;

        if $b2 == 0 goto label07;

        return 0;

     label07:
        $l0 = r0.periodStartTime;

        $l1 = r4.periodStartTime;

        $b2 = $l0 cmp $l1;

        if $b2 == 0 goto label08;

        return 0;

     label08:
        $l0 = r0.minimumRetentionDuration;

        $l1 = r4.minimumRetentionDuration;

        $b2 = $l0 cmp $l1;

        if $b2 == 0 goto label09;

        return 0;

     label09:
        $l0 = r0.scheduleRequestedAt;

        $l1 = r4.scheduleRequestedAt;

        $b2 = $l0 cmp $l1;

        if $b2 == 0 goto label10;

        return 0;

     label10:
        $z0 = r0.expedited;

        $z1 = r4.expedited;

        if $z0 == $z1 goto label11;

        return 0;

     label11:
        $r5 = r0.id;

        $r6 = r4.id;

        $z0 = virtualinvoke $r5.equals($r6);

        if $z0 != 0 goto label12;

        return 0;

     label12:
        $r7 = r0.state;

        $r8 = r4.state;

        if $r7 == $r8 goto label13;

        return 0;

     label13:
        $r5 = r0.workerClassName;

        $r6 = r4.workerClassName;

        $z0 = virtualinvoke $r5.equals($r6);

        if $z0 != 0 goto label14;

        return 0;

     label14:
        $r5 = r0.inputMergerClassName;

        if $r5 == null goto label15;

        $r6 = r4.inputMergerClassName;

        $z0 = virtualinvoke $r5.equals($r6);

        if $z0 != 0 goto label16;

        return 0;

     label15:
        $r5 = r4.inputMergerClassName;

        if $r5 == null goto label16;

        return 0;

     label16:
        $r9 = r0.input;

        $r10 = r4.input;

        $z0 = virtualinvoke $r9.equals($r10);

        if $z0 != 0 goto label17;

        return 0;

     label17:
        $r9 = r0.output;

        $r10 = r4.output;

        $z0 = virtualinvoke $r9.equals($r10);

        if $z0 != 0 goto label18;

        return 0;

     label18:
        $r11 = r0.constraints;

        $r12 = r4.constraints;

        $z0 = virtualinvoke $r11.equals($r12);

        if $z0 != 0 goto label19;

        return 0;

     label19:
        $r13 = r0.backoffPolicy;

        $r14 = r4.backoffPolicy;

        if $r13 == $r14 goto label20;

        return 0;

     label20:
        $r15 = r0.outOfQuotaPolicy;

        $r16 = r4.outOfQuotaPolicy;

        if $r15 != $r16 goto label21;

        return 1;

     label21:
        return 0;
    }

    public boolean hasConstraints()
    {
        androidx.work.Constraints $r1, $r2;
        androidx.work.impl.model.WorkSpec r0;
        boolean $z0;

        r0 := @this;

        $r2 = androidx.work.Constraints.NONE;

        $r1 = r0.constraints;

        $z0 = virtualinvoke $r2.equals($r1);

        $z0 = $z0 ^ 1;

        return $z0;
    }

    public int hashCode()
    {
        androidx.work.BackoffPolicy $r5;
        androidx.work.Constraints $r4;
        long $l2, $l3;
        androidx.work.impl.model.WorkSpec r0;
        androidx.work.WorkInfo$State $r2;
        int $i0, $i1;
        java.lang.String r1;
        androidx.work.OutOfQuotaPolicy $r6;
        androidx.work.Data $r3;
        boolean $z0;

        r0 := @this;

        r1 = r0.id;

        $i0 = virtualinvoke r1.hashCode();

        $i0 = $i0 * 31;

        $r2 = r0.state;

        $i1 = virtualinvoke $r2.hashCode();

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        r1 = r0.workerClassName;

        $i1 = virtualinvoke r1.hashCode();

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        r1 = r0.inputMergerClassName;

        if r1 == null goto label1;

        $i1 = virtualinvoke r1.hashCode();

        goto label2;

     label1:
        $i1 = 0;

     label2:
        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $r3 = r0.input;

        $i1 = virtualinvoke $r3.hashCode();

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $r3 = r0.output;

        $i1 = virtualinvoke $r3.hashCode();

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $l2 = r0.initialDelay;

        $l3 = $l2 >>> 32;

        $l2 = $l2 ^ $l3;

        $i1 = (int) $l2;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $l2 = r0.intervalDuration;

        $l3 = $l2 >>> 32;

        $l2 = $l2 ^ $l3;

        $i1 = (int) $l2;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $l2 = r0.flexDuration;

        $l3 = $l2 >>> 32;

        $l2 = $l2 ^ $l3;

        $i1 = (int) $l2;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $r4 = r0.constraints;

        $i1 = virtualinvoke $r4.hashCode();

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $i1 = r0.runAttemptCount;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $r5 = r0.backoffPolicy;

        $i1 = virtualinvoke $r5.hashCode();

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $l2 = r0.backoffDelayDuration;

        $l3 = $l2 >>> 32;

        $l2 = $l2 ^ $l3;

        $i1 = (int) $l2;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $l2 = r0.periodStartTime;

        $l3 = $l2 >>> 32;

        $l2 = $l2 ^ $l3;

        $i1 = (int) $l2;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $l2 = r0.minimumRetentionDuration;

        $l3 = $l2 >>> 32;

        $l2 = $l2 ^ $l3;

        $i1 = (int) $l2;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $l2 = r0.scheduleRequestedAt;

        $l3 = $l2 >>> 32;

        $l2 = $l2 ^ $l3;

        $i1 = (int) $l2;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $z0 = r0.expedited;

        $i1 = (int) $z0;

        $i0 = $i0 + $i1;

        $i0 = $i0 * 31;

        $r6 = r0.outOfQuotaPolicy;

        $i1 = virtualinvoke $r6.hashCode();

        $i0 = $i0 + $i1;

        return $i0;
    }

    public boolean isBackedOff()
    {
        androidx.work.WorkInfo$State $r1, $r2;
        int $i0;
        androidx.work.impl.model.WorkSpec r0;

        r0 := @this;

        $r2 = r0.state;

        $r1 = androidx.work.WorkInfo$State.ENQUEUED;

        if $r2 != $r1 goto label1;

        $i0 = r0.runAttemptCount;

        if $i0 <= 0 goto label1;

        return 1;

     label1:
        return 0;
    }

    public boolean isPeriodic()
    {
        long $l1;
        byte $b0;
        androidx.work.impl.model.WorkSpec r0;

        r0 := @this;

        $l1 = r0.intervalDuration;

        $b0 = $l1 cmp 0L;

        if $b0 == 0 goto label1;

        return 1;

     label1:
        return 0;
    }

    public void setBackoffDelayDuration(long)
    {
        androidx.work.Logger $r2;
        byte $b1;
        java.lang.Throwable[] $r1;
        int $i2;
        long $l0;
        java.lang.String $r3;
        androidx.work.impl.model.WorkSpec r0;

        r0 := @this;

        $l0 := @parameter0;

        $b1 = $l0 cmp 18000000L;

        $i2 = (int) $b1;

        if $i2 <= 0 goto label1;

        $r2 = androidx.work.Logger.get();

        $r3 = androidx.work.impl.model.WorkSpec.TAG;

        $r1 = newarray (java.lang.Throwable)[0];

        virtualinvoke $r2.warning($r3, "Backoff delay duration exceeds maximum value", $r1);

        $l0 = 18000000L;

     label1:
        $b1 = $l0 cmp 10000L;

        $i2 = (int) $b1;

        if $i2 >= 0 goto label2;

        $r2 = androidx.work.Logger.get();

        $r3 = androidx.work.impl.model.WorkSpec.TAG;

        $r1 = newarray (java.lang.Throwable)[0];

        virtualinvoke $r2.warning($r3, "Backoff delay duration less than minimum value", $r1);

        $l0 = 10000L;

     label2:
        r0.backoffDelayDuration = $l0;

        return;
    }

    public void setPeriodic(long)
    {
        java.lang.Object[] $r3;
        long $l0;
        androidx.work.impl.model.WorkSpec r0;
        androidx.work.Logger $r2;
        byte $b1;
        java.lang.Long $r4;
        java.lang.Throwable[] $r6;
        int $i2;
        java.lang.String $r1, $r5;

        r0 := @this;

        $l0 := @parameter0;

        $b1 = $l0 cmp 900000L;

        $i2 = (int) $b1;

        if $i2 >= 0 goto label1;

        $r2 = androidx.work.Logger.get();

        $r1 = androidx.work.impl.model.WorkSpec.TAG;

        $r3 = newarray (java.lang.Object)[1];

        $r4 = java.lang.Long.valueOf(900000L);

        $r3[0] = $r4;

        $r5 = java.lang.String.format("Interval duration lesser than minimum allowed value; Changed to %s", $r3);

        $r6 = newarray (java.lang.Throwable)[0];

        virtualinvoke $r2.warning($r1, $r5, $r6);

        $l0 = 900000L;

     label1:
        virtualinvoke r0.setPeriodic($l0, $l0);

        return;
    }

    public void setPeriodic(long, long)
    {
        java.lang.Object[] $r3;
        long $l0, $l1;
        androidx.work.impl.model.WorkSpec r0;
        androidx.work.Logger $r1;
        byte $b2;
        java.lang.Long $r4;
        java.lang.Throwable[] $r6;
        int $i3;
        java.lang.String $r2, $r5;

        r0 := @this;

        $l0 := @parameter0;

        $l1 := @parameter1;

        $b2 = $l0 cmp 900000L;

        $i3 = (int) $b2;

        if $i3 >= 0 goto label1;

        $r1 = androidx.work.Logger.get();

        $r2 = androidx.work.impl.model.WorkSpec.TAG;

        $r3 = newarray (java.lang.Object)[1];

        $r4 = java.lang.Long.valueOf(900000L);

        $r3[0] = $r4;

        $r5 = java.lang.String.format("Interval duration lesser than minimum allowed value; Changed to %s", $r3);

        $r6 = newarray (java.lang.Throwable)[0];

        virtualinvoke $r1.warning($r2, $r5, $r6);

        $l0 = 900000L;

     label1:
        $b2 = $l1 cmp 300000L;

        $i3 = (int) $b2;

        if $i3 >= 0 goto label2;

        $r1 = androidx.work.Logger.get();

        $r2 = androidx.work.impl.model.WorkSpec.TAG;

        $r3 = newarray (java.lang.Object)[1];

        $r4 = java.lang.Long.valueOf(300000L);

        $r3[0] = $r4;

        $r5 = java.lang.String.format("Flex duration lesser than minimum allowed value; Changed to %s", $r3);

        $r6 = newarray (java.lang.Throwable)[0];

        virtualinvoke $r1.warning($r2, $r5, $r6);

        $l1 = 300000L;

     label2:
        $b2 = $l1 cmp $l0;

        $i3 = (int) $b2;

        if $i3 <= 0 goto label3;

        $r1 = androidx.work.Logger.get();

        $r2 = androidx.work.impl.model.WorkSpec.TAG;

        $r3 = newarray (java.lang.Object)[1];

        $r4 = java.lang.Long.valueOf($l0);

        $r3[0] = $r4;

        $r5 = java.lang.String.format("Flex duration greater than interval duration; Changed to %s", $r3);

        $r6 = newarray (java.lang.Throwable)[0];

        virtualinvoke $r1.warning($r2, $r5, $r6);

        $l1 = $l0;

     label3:
        r0.intervalDuration = $l0;

        r0.flexDuration = $l1;

        return;
    }

    public java.lang.String toString()
    {
        java.lang.StringBuilder $r1;
        java.lang.String $r2;
        androidx.work.impl.model.WorkSpec r0;

        r0 := @this;

        $r1 = new java.lang.StringBuilder;

        specialinvoke $r1.<init>();

        $r1 = virtualinvoke $r1.append("{WorkSpec: ");

        $r2 = r0.id;

        $r1 = virtualinvoke $r1.append($r2);

        $r1 = virtualinvoke $r1.append("}");

        $r2 = virtualinvoke $r1.toString();

        return $r2;
    }
}
